#!/usr/bin/env python
import argparse
import json
import logging
import re
import subprocess


RE_LOG_FILE = re.compile(r'\/dev\/termination-log(\d+)')


logger = logging.getLogger('openshift_deploy')
logger.setLevel(logging.DEBUG)

ch = logging.StreamHandler()
logger.addHandler(ch)


def setup():
    check_openshift_auth()
    check_docker_auth()

    default_image = 'kpiit-image:latest'
    default_registry = 'openshift-registry.web.cern.ch/it-cda-dr-kpis'

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--image', '-i',
        default=default_image,
        help='docker image name (default: {})'.format(default_image)
    )
    parser.add_argument(
        '--registry', '-r',
        default=default_registry,
        help='OpenShift docker registry (default: {})'.format(default_registry)
    )
    parser.add_argument(
        '--build-only', '-b',
        action='store_true',
        help='build the Docker image without pushing it to OpenShift'
    )
    parser.add_argument(
        '--redeploy-only',
        action='store_true',
        help='redeploy the OpenShift deployment without building and pushing the Docker image'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='verbose output messages'
    )

    return parser.parse_args()


class DeploymentError(Exception):
    def __init__(self, title, message):
        self.title = title
        self.message = message


def check_openshift_auth():
    result = subprocess.run(
        ['oc', 'whoami'],
        stderr=subprocess.PIPE,
        stdout=subprocess.DEVNULL
    )
    if result.returncode != 0:
        logger.error('Not authenticated with OpenShift')
        raise DeploymentError('OpenShift Auth Failed',
                              result.stderr.decode('utf-8'))


def check_docker_auth():
    cmd = 'docker login -u openshift -p $(oc whoami -t) openshift-registry.web.cern.ch'
    result = subprocess.run(
        cmd,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL
    )
    msg = result.stdout.decode('utf-8')
    if msg != 'Login Succeeded\n':
        logger.error('Not authenticated with Docker')
        raise DeploymentError('Docker Auth Failed',
                              result.stdout.decode('utf-8'))


def run_command(cmd, args):
    output = subprocess.PIPE if args.verbose else subprocess.DEVNULL

    cmd_kwargs = dict(stdout=output, stderr=output)

    if args.verbose:
        result = subprocess.run(cmd, shell=True)
    else:
        result = subprocess.run(cmd, shell=True, **cmd_kwargs)

    if result.returncode != 0:
        msg = '{cmd}: {obj}'.format(cmd=cmd, obj=result)
        raise DeploymentError('Command Failed', msg)


def build_docker_image(args):
    cmd = 'docker build --no-cache=true --network=host -t {image} .'.format(
        image=args.image
    )
    logger.debug('Build command: %s' % cmd)
    logger.info('Building docker image...')

    run_command(cmd, args)

    logger.debug('Docker image build was successful.')


def tag_docker_image(args):
    cmd = 'docker tag {image_tag} {registry}/{image}'.format(
        image_tag=args.image,
        registry=args.registry,
        image=args.image.split(':')[0]
    )
    logger.debug('Tag command: %s' % cmd)
    logger.info('Tagging docker image...')

    run_command(cmd, args)

    logger.debug('Docker tag was successful.')


def push_docker_image(args):
    cmd = 'docker push {registry}/{image}'.format(
        registry=args.registry,
        image=args.image.split(':')[0]
    )
    logger.debug('Push command: %s' % cmd)
    logger.info('Pushing docker image to OpenShift...')

    run_command(cmd, args)

    logger.debug('Docker image was successfully pushed to OpenShift.')


def redeploy(args):
    """Re-deploy the OpenShift deployment using the latest pushed tag."""
    cmd = 'oc get --export deployment.apps/worker -o json'
    result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
    config = json.loads(result.stdout.decode('utf-8'))

    # Change the termination log filename to force re-deployment
    # TODO: Find a cleaner approach
    containers = config['spec']['template']['spec']['containers']
    log_file = containers[0]['terminationMessagePath']
    m = RE_LOG_FILE.match(log_file)
    if m:
        num = int(m.group(1))
        log_file = log_file.replace(m.group(1), str(num + 1))
        containers[0]['terminationMessagePath'] = log_file
    else:
        raise DeploymentError('Failed Parsing Filename', log_file)

    data = dict(spec=dict(template=dict(spec=dict(
        containers=containers
    ))))

    cmd = "oc patch deployment.apps/worker -p '{}'".format(json.dumps(data))

    logger.debug('Re-deploy command: %s' % cmd)
    logger.info('Re-deploying OpenShift deployment...')

    run_command(cmd, args)

    logger.debug('OpenShift deployment restarted successfully.')


if __name__ == '__main__':
    try:
        args = setup()

        if not args.redeploy_only:
            build_docker_image(args)
            tag_docker_image(args)

            if not args.build_only:
                push_docker_image(args)

        redeploy(args)

    except DeploymentError as de:
        logger.error('[{title}] {msg}'.format(title=de.title, msg=de.message))
    except KeyboardInterrupt:
        logger.info('Exiting...')
